(reduce concat 0 '(1 2 3 4 5))
(reduce concat '() '(1 2 3 4 5))
(reduce concat '() (1 2 3 4 5))
(+ 0 (1 2 3 4))
(+ 0 [1 2 3 4])
(reduce + 0 [1 2 3 4])
(reduce concat '() [1 2 3 4])
(reduce concat '() [(1) (2) (3) (4)])
(reduce concat '() [[1] [2] [3] [4]])
(reduce concat '() [[1] [2] [3] [4 5 6 7]])
quit
(defn str-cat [a-seq] (reduce str a-seq))
(str-cat ["I" "am" "Legend"])
(defn str-cat [a-seq] (reduce (fn [string] (str string " ")) a-seq))
(str-cat ["I" "am" "Legend"])
(str "Hello" " " "World")
(str-cat ["I" "am" "Legend"])
(defn str-cat [a-seq] (reduce (fn [v r] (str v " " r)) a-seq))
(str-cat ["I" "am" "Legend"])
quit
(defn my-interpose [x a-seq] (reduce (fn [a b] (cons (conj a x) b)) a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce (fn [a b] (conj a x)) a-seq))
(my-interpose 0 [1 2 3])
(conj (1 2 3) 1)
(conj '(1 2 3) 1)
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce (fn [a b] (conj (seq a) x)) a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce conj a-seq))
(my-interpose 0 [1 2 3])
(concat [1 3 4] [2 5])
(defn my-interpose [x a-seq] (reduce (fn [v r] (concat (conj v x) r)) a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce (fn [v r] (concat v r)) a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce (fn [value rest-seq] (concat (conj (seq value x)) rest-seq)) a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce (fn [value rest-seq] (concat (conj (seq value) x) rest-seq)) a-seq))
(my-interpose 0 [1 2 3])
(conj (seq 1) 2)
(conj (cons 1) 2)
(conj (cons 1 '()) 2)
(defn my-interpose [x a-seq] (reduce (fn [value rest-seq] (concat (conj (cons x '()) value) rest-seq)) a-seq))
(conj (cons 1 '()) 2)
(my-interpose 0 [1 2 3])
(concat (conj (cons 0 '()) 5) [1 2 3 4]))
(concat (conj (cons 0 '()) 5) [1 2 3 4])
(defn my-interpose [x a-seq] (reduce (fn [value rest-seq] (concat rest-seq (conj (cons x '()) value))) a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce (fn [value rest-seq] (concat (cons rest-seq '()) (conj (cons x '()) value))) a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce conj a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce cons a-seq))
(my-interpose 0 [1 2 3])
quit
(defn my-count [a-seq] (reduce (fn [size elem] (inc size)) 0 a-seq))
(my-count [1 2 3])
(my-count [])
(my-count [1])
quit
(defn my-interpose [x a-seq] (reduce (fn [new-seq elem] (conj (conj new-seq elem) x) '() a-seq)))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce (fn [new-seq elem] (conj (conj new-seq elem) x)) '() a-seq))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (if (empty? a-seq)
                               '()
                               (reduce (fn [new-seq elem] (conj (conj new-seq elem) x)) (cons (first a-seq)) (rest a-seq))))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (if (empty? a-seq)
                               '()
                               (reduce (fn [new-seq elem] (conj (conj new-seq elem) x)) (cons (first a-seq) '()) (rest a-seq))))
(my-interpose 0 [1 2 3])
(defn my-interpose [x a-seq] (reduce (fn [new-seq elem] (conj (conj new-seq elem) x)) '() a-seq))
(my-interpose 0 [1 2 3])
(conj [1 2 3] 4)
(conj 4 [1 2 3])
(conj [1 2 3] 0)
(defn my-interpose [x a-seq] (reduce (fn [new-seq elem] (conj new-seq elem)) '() a-seq))
(my-interpose 0 [1 2 3])
quit
(defn min-max-element [a-seq] (let [starting-value (cons (first a-seq) (cons (first a-seq) '()))
                                    helper (fn [min-max elem] (if (or (< elem (get min-max 0)) (> elem (get min-max 1)))
                                                                (if (< elem (get min-max 0))
                                                                  (assoc min-max 0 elem)
                                                                  (assoc min-max 1 elem))
                                                                min-max))]
                                (reduce helper starting-value (rest a-seq))))
(min-max-element [2 7 3 15 4])
(cons (first [2 7 3 15 4]) (cons (first [2 7 3 15 4]) '()))
(defn min-max-element [a-seq] (let [starting-value (vector (cons (first a-seq) (cons (first a-seq) '())))
                                    helper (fn [min-max elem] (if (or (< elem (get min-max 0)) (> elem (get min-max 1)))
                                                                (if (< elem (get min-max 0))
                                                                  (assoc min-max 0 elem)
                                                                  (assoc min-max 1 elem))
                                                                min-max))]
                                (reduce helper starting-value (rest a-seq))))
(min-max-element [1 2 3 4])
quit
(+ 4 8 34 11 11 26 8 12 15)
(+ 4 8 34 11 11 26 8)
quit
(conj [1 2 3] 4)
(conj (1 2 3) 4)
(conj '(1 2 3) 4)
(defn my-interpose [x a-seq] (reduce (fn [interpose-vec elem] (conj (conj interpose-vec elem) x)) []))
(my-interpose 0 [1 2 3 4])
(defn my-interpose [x a-seq] (reduce (fn [interpose-vec elem] (conj (conj interpose-vec elem) x)) [] a-seq))
(my-interpose 0 [1 2 3 4])
(defn my-interpose [x a-seq] (reduce (fn [interpose-vec elem] (if (= (- (count interpose-vec) 1) (count a-seq))
                                                                (conj interpose-vec elem)
                                                                (conj (conj interpose-vec elem) x))) [] a-seq))
(my-interpose 0 [1 2 3 4])
(defn my-interpose [x a-seq] (reduce (fn [interpose-vec elem] (conj (conj interpose-vec elem) x)) [] a-seq))
(my-interpose 0 [1 2 3 4])
(defn my-interpose [x a-seq] (rest (reduce (fn [interpose-vec elem] (conj (conj interpose-vec elem) x)) [] a-seq)))
(my-interpose 0 [1 2 3 4])
(defn my-interpose [x a-seq] (reduce (fn [interpose-vec elem] (if (= (count interpose-vec) (- (count a-seq) 1))
                                                                (conj interpose-vec elem)
                                                                (conj (conj interpose-vec elem) x))) [] a-seq))
(my-interpose 0 [1 2 3 4])
(defn my-interpose [x a-seq] (reduce (fn [interpose-vec elem] (if (empty? (rest a-seq))
                                                                (conj interpose-vec elem)
                                                                (conj (conj interpose-vec elem) x))) [] a-seq))
(my-interpose 0 [1 2 3 4])
(defn my-interpose [x a-seq] (reverse (rest (reverse (reduce (fn [interpose-vec elem] (conj (conj interpose-vec elem) x)) [] a-seq)))))
(my-interpose 0 [1 2 3 4])
(my-interpose 0 [])
quit
[(first [1 2 3 4]) (first [1 2 3 4])]
(defn min-max-element [a-seq] (reduce (fn [min-max elem] (if (or (< elem (get min-max 0)) (> elem (get min-max 1)))
                                                           (if (< elem (get min-max 0))
                                                             (assoc min-max 0 elem)
                                                             (assoc min-max 1 elem))
                                                           min-max)) [(first a-seq) (first a-seq)] (rest a-seq)))
(min-max-element [2 7 3 15 4])
(min-max-element [1])
(min-max-element [])
quit
(concat [1 2 3] [4 5 6])
(defn insert-helper [sorted-vec n cut] (if (empty? sorted-seq)
                                         cut
                                         (if (< (first sorted-seq n))
                                           (insert-helper (vector (rest sorted-vec)) n (assoc cut 0 (conj (get cut 0) (first sorted-vec))))
                                           (insert-helper (vector (rest sorted-vec)) n (assoc cut 1 (conj (get cut 1) (first sorted-vec)))))))
(defn insert-helper [sorted-vec n cut] (if (empty? sorted-vec)
                                         cut
                                         (if (< (first sorted-vec n))
                                           (insert-helper (vector (rest sorted-vec)) n (assoc cut 0 (conj (get cut 0) (first sorted-vec))))
                                           (insert-helper (vector (rest sorted-vec)) n (assoc cut 1 (conj (get cut 1) (first sorted-vec)))))))
(insert-helper [1 2 3 4 6 7 8] 5 [[] []])
(defn insert-helper [sorted-vec n cut] (if (empty? sorted-vec)
                                         cut
                                         (if (< (first sorted-vec) n)
                                           (insert-helper (vector (rest sorted-vec)) n (assoc cut 0 (conj (get cut 0) (first sorted-vec))))
                                           (insert-helper (vector (rest sorted-vec)) n (assoc cut 1 (conj (get cut 1) (first sorted-vec)))))))
(insert-helper [1 2 3 4 6 7 8] 5 [[] []])
(rest [1 2 3])
(rest [3])
(rest [2 3])
(vector (rest [1 2 3]))
(defn insert-helper [sorted-seq n cut] (if (empty? sorted-seq)
                                         cut
                                         (if (< (first sorted-seq) n)
                                           (insert-helper (rest sorted-seq) n (assoc cut 0 (conj (get cut 0) (first sorted-seq))))
                                           (insert-helper (rest sorted-seq) n (assoc cut 1 (conj (get cut 1) (first sorted-seq)))))))
(insert-helper [1 2 3 4 6 7 8] 5 [[] []])
(defn insert-helper2 [sorted-seq n new-vec] (if (empty? sorted-seq)
                                               new-vec
                                              (if (> (first sorted-seq) n)
                                                (insert-helper2 (rest sorted-seq) n (conj (conj new-vec n) (first sorted-seq)))
                                                (insert-helper2 (rest sorted-seq) n (conj new-vec (first sorted-seq))))))
(insert-helper2 [1 2 3 4 6 7 8] 5 [[] []])
(insert-helper2 [1 2 3 4 6 7 8] 5 [])
(defn insertion-sort [a-seq] (reduce (fn [sorted-vec elem] (insert sorted-vec elem)) [] a-seq))
(defn insert [sorted-seq n] (insert-helper sorted-seq n []))
(defn insert-helper [sorted-seq n new-vec] (if (empty? sorted-seq)
                                               new-vec
                                              (if (> (first sorted-seq) n)
                                                (insert-helper (rest sorted-seq) n (conj (conj new-vec n) (first sorted-seq)))
                                                (insert-helper (rest sorted-seq) n (conj new-vec (first sorted-seq))))))
(defn insert [sorted-seq n] (insert-helper sorted-seq n []))
(defn insertion-sort [a-seq] (reduce (fn [sorted-vec elem] (insert sorted-vec elem)) [] a-seq))
(insertion-sort [2 5 3 1])
(insert [1 3 4] 2)
(defn insert-helper [sorted-seq n new-vec bool_inserted] (if (empty? sorted-seq)
                                               new-vec
                                              (if (and (> (first sorted-seq) n) (not bool_inserted))
                                                (insert-helper (rest sorted-seq) n (conj (conj new-vec n) (first sorted-seq)) true)
                                                (insert-helper (rest sorted-seq) n (conj new-vec (first sorted-seq)) bool_inserted))))
(insert [1 3 4] 2)
(defn insert [sorted-seq n] (insert-helper sorted-seq n [] false))
(insert [1 3 4] 2)
(insertion-sort [2 5 3 1])
(insert [] 1)
(defn insert [sorted-seq n] (if (empty? sorted-seq)
                              (cons n '())
                              (insert-helper sorted-seq n [] false)))
(insert [] 1)
(insertion-sort [2 5 3 1])
(insert [1 3 4] 2)
(insertion-sort [2 5 3 1])
(insert [5] 2)
(insert [1] 2)
(defn insert-helper [sorted-seq n new-vec bool_inserted] (if (empty? sorted-seq)
                                              (if (bool_inserted)
                                                new-vec
                                                (conj new-vec n))
                                              (if (and (> (first sorted-seq) n) (not bool_inserted))
                                                (insert-helper (rest sorted-seq) n (conj (conj new-vec n) (first sorted-seq)) true)
                                                (insert-helper (rest sorted-seq) n (conj new-vec (first sorted-seq)) bool_inserted))))
(insert [1] 2)
(defn insert-helper [sorted-seq n new-vec bool_inserted] (if (empty? sorted-seq)
                                              (if bool_inserted
                                                new-vec
                                                (conj new-vec n))
                                              (if (and (> (first sorted-seq) n) (not bool_inserted))
                                                (insert-helper (rest sorted-seq) n (conj (conj new-vec n) (first sorted-seq)) true)
                                                (insert-helper (rest sorted-seq) n (conj new-vec (first sorted-seq)) bool_inserted))))
(insert [1] 2)
(insertion-sort [2 5 3 1])
quit
(defn minus ([x] -x) ([x y] (- x y)))
(minus 1)
quit
(minus 1)
quit
(defn count-params ([x] 1) ([x & more] (reduce (fn [counter elem] (+ counter 1)) 1 more)))
(count-params :a)
(count-params :a 1 :b :c)
(count-params)
quit
(defn my-* ([] 1) ([x] x) ([x y] (* x y)) ([x y & more] (reduce (fn [product elem] (* product elem)) 1 more)))
(my-* 1 2 3 4 5)
quit
(defn pred-and 
  ([] (fn [x] true))
  ([pred?] (fn [x] (pred? x)))
  ([pred? pred-2?] (fn [x] (and (pred? x) (pred-2? x))))
  ([pred? pred-2? & more] (fn [x] (reduce and (and (pred? x) (pred-2 x)) more))))
(defn pred-and 
  ([] (fn [x] true))
  ([pred?] (fn [x] (pred? x)))
  ([pred? pred-2?] (fn [x] (and (pred? x) (pred-2? x))))
  ([pred? pred-2? & more] (fn [x] (reduce and (and (pred? x) (pred-2? x)) more))))
(defn pred-and 
  ([] (fn [x] true))
  ([pred?] (fn [x] (pred? x)))
  ([pred? pred-2?] (fn [x] (and (pred? x) (pred-2? x)))))
(reduce and [true true false])
(defn pred-and 
  ([] (fn [x] true))
  ([pred?] (fn [x] (pred? x)))
  ([pred? pred-2?] (fn [x] (and (pred? x) (pred-2? x))))
  ([pred? pred-2? & more] (fn [x] (reduce (fn [state elem] (if state (elem x) false) (and (pred? x) (pred-2? x)) more)))))
(filter (pred-and) [1 0 -2])
(filter (pred-and pos? odd?) [1 2 -4 0 6 7 -3])
(filter (pred-and number? integer? pos? even?)
        [1 0 -2 :a 7 "a" 2])
(defn pred-and 
  ([] (fn [x] true))
  ([pred?] (fn [x] (pred? x)))
  ([pred? pred-2?] (fn [x] (and (pred? x) (pred-2? x))))
  ([pred? pred-2? & more] (fn [x] (reduce (fn [state elem] (if state (elem x) false)) (and (pred? x) (pred-2? x)) more))))
(filter (pred-and number? integer? pos? even?)
        [1 0 -2 :a 7 "a" 2])
(pos? 0)
quit
(defn parity [a-seq] (let [toggle (fn [a-set elem] [a-set elem] (if (contains? a-set elem) (disj a-set elem) (conj a-set elem)))]
                       (reduce (fn [odd-set elem] (toggle odd-set elem)) #{} a-seq)))
(parity [:a :b :c])
(parity [:a :a :b :b])
(parity [1 2 3 1])
quit
